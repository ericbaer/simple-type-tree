-----------------------------------------------------------------------------
--
-- Module      :  Data.TypeTree.TH
-- Copyright   :
-- License     :  BSD3
--
-- Maintainer  :
-- Stability   :
-- Portability :
--
-- | Template Haskell functionality for working with type trees.
--
-----------------------------------------------------------------------------
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE LambdaCase #-}
module Data.TypeTree.TH (
    -- * Comparing types
    typeInstanceCompare,
    typeInstanceCompareQ,
    -- * Building trees
    treeType,
    keyValueTreeType,
    -- * General utilities
    eitherQ,
    unfoldAppT,
    unfoldAppE,
    flattenAppTCon,
    flattenAppT2,
    unflattenAppT2,
    thToSTypeRep,
    thToSTyCon
) where

import Prelude hiding (exp, sequence, mapM)
import Control.Applicative
import Control.Monad ((<=<))
import Data.Function
import Data.List
import Data.Maybe
import Data.Traversable
import Language.Haskell.TH
import Language.Haskell.TH.ExpandSyns
import Language.Haskell.TH.Syntax

import qualified Data.Sequence as Seq
import qualified Data.Text as Text

import Data.TypeTree.Operations
import Data.TypeTree.Tree
import Data.TypeRepLike.STypeRep

-----------------------------------------------------------------------------
-- Comparing types
-----------------------------------------------------------------------------

-- | Generates 'Compare' type instances for the 'Name'd types. Skips types
--   which already have an instance. Will merrily go and declare duplicate
--   instances if you have duplicate entries in your list, leading to
--   compilation errors.
typeInstanceCompare :: [Name] -> Q [Dec]
typeInstanceCompare = typeInstanceCompareAllTypes . map ConT

-- | Generates 'Compare' instances for type quotations. Skips types which
--   already have an instance. Will merrily go and declare duplicate instances
--   if you have duplicate entries in your list, leading to compilation errors.
typeInstanceCompareQ :: [Q Type] -> Q [Dec]
typeInstanceCompareQ = typeInstanceCompareAllTypes <=< mapM expandSyns <=<
    sequence

-- | Generates 'Compare' instances for the cartesian product of the given
--   list of 'Type's.
--   FIXME: require both parameters to be of the same kind?
typeInstanceCompareAllTypes :: [Type] -> Q [Dec]
typeInstanceCompareAllTypes types = do
    FamilyI _ insts <- reify ''Compare
    let f = uncurry (typeInstanceCompareTypes insts)
    cleanTypes <- mapM noTypeFamilies types
    return $ catMaybes $ map f $ liftA2 (,) cleanTypes cleanTypes

-- | Generates a 'Compare' instance for the two 'Type's. Does /not/ generate
--   a 'Compare' instance for the same types in the opposite order.
typeInstanceCompareTypes :: [Dec] -> Type -> Type -> Maybe Dec
typeInstanceCompareTypes insts a b = maybe (Just ab) (const Nothing) minst
    where
        ab = TySynInstD ''Compare (TySynEqn [a, b] $ a `versus` b)
        minst = findConcreteInstance [a, b] insts

-----------------------------------------------------------------------------
-- Building trees
-----------------------------------------------------------------------------

-- | Generates a tree of 'Node's containing the types passed in. The types in
--   the left branch are guaranteed to precede the type at the root in
--   lexicographic order, and similarly the types in the right branch are
--   guaranteed to follow the types at the root in lexicographic order.
--   For example:
--
--   > type Bar = $(treeType [''Int, ''Char, ''(), ''Double])
--
--   Is equivalent to:
--
--   > type Bar =
--   >     Node Double
--   >         (Node Char
--   >             (Node () Leaf Leaf)
--   >             Leaf)
--   >     (Node Int Leaf Leaf)
--
--   A tree generated by this splice is guaranteed to be a 'BalancedTree'. If
--   you define the necessary 'Compare' instances for all the pairs of types in
--   the tree (e.g. using 'typeInstanceCompare'), then it will also be an
--   'OrderedTree'. The latter step is necessary if you plan to use
--   'Data.TypeTree.ConstrainAll.ConstrainAll' or any other functions which
--   depend on the ordering of types in the tree (to decide whether to go
--   left or right when searching for a particular type).
--
--   It would have been nice to provide a type family to allow us to construct
--   these trees on the fly, but it would require nested type family
--   applications and thus '-XUndecidableInstances' (and even then,
--   tree-rebalancing at the type level would certainly be a godawful mess).
treeType :: [Name] -> Q Type
treeType = treeTypeQ . map conT

-- | For when you want to pass quoted types, rather than simple 'Name's.
treeTypeQ :: [Q Type] -> Q Type
treeTypeQ = go <=< sequence where
    typeRepTuple x = (,,) <$> eitherQ (thToSTypeRep x) <*> pure x <*> pure x
    go = keyValueTreeType <=< mapM (typeRepTuple) <=< mapM noTypeFamilies <=<
        mapM expandSyns

-- | Like 'treeType', but with '(key, value)' type pairs; you get a tree of
--   the 'value's, sorted in lexicographic order of the 'key's.
--   FIXME: is it possible to put it in 'TypeRep' order instead? This would
--   require getting the GHC fingerprint /during/ compilation.
keyValueTreeType :: [(STypeRep, Type, Type)] -> Q Type
keyValueTreeType []          = [t| Leaf |]
keyValueTreeType [(_, _, n)] = [t| Node $(pure n) Leaf Leaf|]
keyValueTreeType ns = [t| Node $(pure mid) $(left) $(right)|] where
    sortedNames = sortBy (compare `on` (\(a, _, _) -> a)) ns
    chunkLength = floor $ fromIntegral (length sortedNames) / (2.0 :: Double)
    left = keyValueTreeType $ take chunkLength sortedNames
    mid = (\(_, b, _) -> b) $ head $ drop chunkLength sortedNames
    right = keyValueTreeType $ drop (chunkLength + 1) sortedNames


-- FIXME: do we need functions to insert types into trees?

-----------------------------------------------------------------------------
-- Working with 'Type's and 'STypeRep'
-----------------------------------------------------------------------------

-- | Converts a Template Haskell 'Type' which consists solely of concrete types
--   into an 'STypeRep'
--   FIXME: handle promoted types, etc.
thToSTypeRep :: Type -> Either String STypeRep
thToSTypeRep ty = STypeRep <$> con <*> args where
    go (ConT nm)  = thToSTyCon nm
    go ListT      = pure listTc
    go ArrowT     = pure funTc
    go (TupleT n) = pure (mkTupleTc n)
    go other      = Left $ "Expecting concrete type; got " ++ show other
    u             = unfoldAppT ty
    con           = go $ head u
    args          = fmap Seq.fromList $ mapM thToSTypeRep $ tail u

thToSTyCon :: Name -> Either String STyCon
thToSTyCon (Name (OccName occ) (NameG _ (PkgName pkg) (ModName modl))) =
    return $ STyCon (Text.pack pkg) (Text.pack modl) (Text.pack occ)
thToSTyCon x = Left $ "Can only convert NameG to STyCon; got " ++ show x

-----------------------------------------------------------------------------
-- FIXME: hasn't all this stuff been written before, somewhere?
-----------------------------------------------------------------------------

-- | Finds instances defined on the concrete 'Type's in the first list.
--   Makes no attempt whatsoever to unify with any type variables.
findConcreteInstance :: [Type] -> [Dec] -> Maybe Type
findConcreteInstance _ [] = Nothing
findConcreteInstance names ((TySynInstD _ (TySynEqn lhs rhs)):is) =
    if lhs == names then Just rhs else findConcreteInstance names is
findConcreteInstance _ _  = Nothing

-- | Lifts an 'Either' into 'Q'.
eitherQ :: Either String a -> Q a
eitherQ = either fail return

-- | Compare two types and return their 'Ordering' as a 'PromotedT'.
versus :: Type -> Type -> Type
versus l r = PromotedT $ case (compare `on` thToSTypeRep) l r of
    { LT -> 'LT; EQ -> 'EQ; GT -> 'GT }

-- | If the type has no type family invocations in it, 'return' , else 'fail'.
noTypeFamilies :: Type -> Q Type
noTypeFamilies (ForallT b p t) = ForallT b p <$> noTypeFamilies t
noTypeFamilies (SigT t k)      = SigT <$> noTypeFamilies t <*> pure k
noTypeFamilies (AppT l r)      = AppT <$> noTypeFamilies l <*> noTypeFamilies r
noTypeFamilies (ConT name)     = reify name >>= \case
    TyConI (DataD{}) ->
        return $ ConT name -- data constructors are fine
    TyConI (TySynD _ bndrs ty) -> do
        cleanTy <- noTypeFamilies ty
        return $ if null bndrs then cleanTy else ForallT bndrs [] cleanTy
    FamilyI (FamilyD flav _ _ _) _ ->
        case flav of
            DataFam -> return $ ConT name -- data families are fine, I guess
            TypeFam -> do
                reportError $ "Cannot use type family " ++ show name ++ " here"
                return $ ConT name
    other -> do
        reportError $ (show name) ++ " is unexpected, not a concrete type: " ++
            pprint other ++ "\n" ++ show other
        return $ ConT name
noTypeFamilies other           = return other

-- | Unfolds a left-branching 'AppT' tree into a list, such that, e.g.
--   > F Int Double String
--   becomes:
--   > [ConT F, ConT GHC.Types.Int, ConT GHC.Types.Double,
--   >     ConT GHC.Base.String]
--   To return to the original, use 'foldl'.
unfoldAppT :: Type -> [Type]
unfoldAppT = reverse . unfoldAppT' where
    unfoldAppT' (AppT a@(AppT _ _) b) = b : unfoldAppT' a
    unfoldAppT' (AppT a b) = [b, a]
    unfoldAppT' other = [other]

-- | Unfolds a left-branching 'AppE' tree into a list, such that, e.g.
--   > f a b c
--   becomes:
--   > [VarE f, VarE a, VarE b, VarE c]
unfoldAppE :: Exp -> [Exp]
unfoldAppE = reverse . unfoldAppE' where
    unfoldAppE' (AppE a@(AppE _ _) b) = b : unfoldAppE' a
    unfoldAppE' (AppE a b) = [b, a]
    unfoldAppE' other = [other]

-- | Unfolds a right-branching 'AppT' tree, to "flatten" nested constructor
--   applications like
--   > F Int Double (F String Float (F () [Int] Dec))
--   into:
--   > [[ConT GHC.Types.Int, ConT GHC.Types.Double],
--   >  [ConT GHC.Base.String,ConT GHC.Types.Float],
--   >  [TupleT 0, AppT ListT (ConT GHC.Types.Int),
--   >   ConT Language.Haskell.TH.Syntax.Dec]]
--   The first parameter should be a 'ConT', 'ArrowT', or something similar
flattenAppTCon :: Type -> Type -> [[Type]]
flattenAppTCon con ty = map tail $ flattenAppTCon' ty where
    flattenAppTCon' ab@(AppT a b) = let ua = unfoldAppT a in
        if head ua == con
        then let ub = flattenAppTCon' b in
            if head (head ub) == con
                then ua : ub
                else [ua ++ head ub]
        else [[ab]]
    flattenAppTCon' other = [[other]]

-- | "Flatten"s the repeated application of a type constructor taking two
--   arguments, so that, for example
--
--   > Int ::: Double ::: String ::: EndOfList
--
--   becomes:
--
--   > [ConT GHC.Types.Int, ConT GHC.Types.Double, ConT GHC.Base.String,
--   >  ConT Data.TypeTree.List.EndOfList]
flattenAppT2 :: Type -> Type -> [Type]
flattenAppT2 wantCon ty =  f $ flattenAppTCon wantCon ty where
    f []     = [] -- never happens, a Type cannot be empty like this
    f (x:[]) = x -- preserves the EndOfList in [a, EndOfList]
    f (x:xs) = head x : f xs

unflattenAppT2 :: Type -> Type -> [Type] -> Type
unflattenAppT2 con lastTy tys = foldr mkCon lastTy tys where
    mkCon l r = (con `AppT` l) `AppT` r
